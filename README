This is a solution to the first reader-writer problem implemented in C with
mutex locks, semaphores, and shared memory representing the file.

Assumptions and problem definitions:
* Readers and writers need to access a file which will be represented by shared
  memory.
* The "file" will be referred to as "the space" or "the file".
* Only one writer can write to the space at a time, during which, no readers
  may be reading (as they may be reading incomplete data).
* Since readers don't modify the data, multiple readers may access the space at
  one time.

Implications:
* A writer that never stops writing will starve the readers.
* If a reader is reading and another reader enters, it will begin reading
  regardless of whether a writer is waiting. This results in starvation of
  writers.

A few comments:
* Since shared memory (and files) are available to all processes, this could be
  implemented with interprocess communication, but since multi-threading is
  easier, I am using threads instead.
* I could have each thread access an actual file, but with shared memory, it's
  easier to demonstrate exactly where the threads are writing too. Also, I'm
  not sure if the file I/O libraries or operating system do any concurrency of
  their own. With shared memory, there is none.
